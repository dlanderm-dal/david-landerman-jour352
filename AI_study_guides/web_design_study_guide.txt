PORTABLE WEB DESIGN STUDY GUIDE AND BLUEPRINT
Document Version: 1.0
Source Files: index.html, style.css (original) | index_clauderevL.html, style_clauderevL.css (revised)
Purpose: Teach web design concepts by comparing original student work to professionally revised version, then provide blueprint for building similar single-page websites

INSTRUCTIONS FOR CLAUDE (FUTURE USE):
This document is portable. When a user uploads this document along with the four source files (index.html, style.css, index_clauderevL.html, style_clauderevL.css), Claude should be able to render any section on request. The user will say something like "Render Concept 3" or "Render Blueprint Section 2" and Claude should create a visually appealing artifact (HTML or React) that teaches that specific section with code examples drawn from the source files. Each section contains RENDER INSTRUCTIONS that describe what the rendered output should include. The user skill level is slightly beyond beginner - they took one semester of HTML/CSS but it did not stick well. Explanations should be clear, use analogies where helpful, and always show before/after comparisons from the source files. Bootstrap concepts should be explained thoroughly as the grid system is particularly fuzzy for the user.
All study-guides/blueprints should be in html format.
CONSERVE CONTEXT: I.e. dont start things over again when theres a draft, edit. Also consider when minor changes need to be made edit lines vs delete and rewrite them.

TABLE OF CONTENTS

PART ONE: STUDY GUIDE (BY CONCEPT)
Concept 1: Document Structure and Semantic HTML
Concept 2: CSS Organization and the Cascade
Concept 3: CSS Custom Properties and Theming
Concept 4: Class Naming Conventions
Concept 5: The CSS Box Model
Concept 6: Bootstrap Grid System (Containers, Rows, Columns)
Concept 7: Bootstrap Breakpoints and Responsive Classes
Concept 8: Bootstrap Spacing and Display Utilities
Concept 9: Flexbox Layout
Concept 10: Fixed Positioning and the Sidebar Pattern
Concept 11: The Hero Section Pattern
Concept 12: Card Component Pattern
Concept 13: Typography, Color, and Visual Design Best Practices
Concept 14: Transitions and Hover Effects
Concept 15: Media Queries for Responsive Design
Concept 16: Deprecated Practices and Common Mistakes to Avoid

PART TWO: BLUEPRINT (BY PAGE SECTION)
Blueprint Section 1: HTML Boilerplate and Head Setup
Blueprint Section 2: Navigation (Desktop Sidebar and Mobile Navbar)
Blueprint Section 3: Hero/Title Section
Blueprint Section 4: Content Sections (Repeatable Pattern)
Blueprint Section 5: Card Components (Experience, Education, Challenge, Feature Cards)
Blueprint Section 6: Carousel/Gallery Component
Blueprint Section 7: Contact and Call-to-Action Section
Blueprint Section 8: Putting It All Together (Full Page Structure)

BEGIN STUDY GUIDE

CONCEPT 1: DOCUMENT STRUCTURE — WHEN DO YOU ACTUALLY NEED A WRAPPER?

What it is:
When learning CSS, a common instinct is to add a wrapper div whenever you need styling: "I need padding here—better wrap it." "I need a border—let me add a container." Before long, you have divs nested 5-6 levels deep, and you're not sure which one is doing the work. The core skill is recognizing that every HTML element is already a box with padding, border, and margin available—so most "wrapper instinct" decisions are unnecessary.

How it appeared in original:
The original had excessive nesting throughout. The card header structure went 5 levels deep: card_heading_container → row card_heading → col-md-4 → corporate_logo → img. Each wrapper was added out of uncertainty about where styling should go. The education section used empty col-md-1 columns as spacers (1 + 5 + 5 + 1 = 12) instead of applying padding to a container. Section bodies used section_body_container with col-md-10 offset-md-1 to control width, when CSS max-width and margin: auto would be simpler.

How it was applied in revL:
RevL reduces nesting by applying styles directly to elements that already exist. The card header becomes 2 levels: card-header-row (needed for flexbox layout) → company-logo and company-info (grouping children). Padding and borders go on card-header-row directly, not a separate wrapper. Education sections use padding on section-content instead of empty columns. Section width is controlled with max-width: 1200px and margin: 0 auto on the container, not Bootstrap column math.

The decision framework — before adding a wrapper, ask:
1. Can I put this style on an element that already exists? (padding, border, background can go on existing elements)
2. Am I using this just for spacing? (use margin, padding, or gap instead of empty divs)
3. Do I need a new layout context? (this IS a valid reason—flexbox/grid need a parent element)
4. Does Bootstrap require this structure? (row → col is required, but you control nesting outside that)

Key examples from original → revL:
- Card header: 5 levels → 2 levels. Padding moved to card-header-row. Bootstrap row/cols replaced with simpler flexbox.
- Education spacing: Empty col-md-1 spacers → padding: 2rem on section-content
- Section width: col-md-10 offset-md-1 → max-width: 1200px; margin: 0 auto

Connection to box model:
Every element already has content, padding, border, and margin layers. You don't need a wrapper to add padding—just add padding. You don't need a wrapper for a border—just add a border. The only time you need a new element is when you need a new box with its own layout behavior (flex container, grid container) or positioning context.

GAP VS PADDING VS MARGIN — WHERE DOES "GAP" FIT?

The box model describes the layers of ONE element. But gap is different—it's set on a parent container (flex or grid) and creates space BETWEEN its children. No single child "owns" that space.

The distinction:
- padding: Set on parent. Creates space between parent's edge and its children.
- gap: Set on parent. Creates space between sibling children.
- margin: Set on child. Creates space outside that child's own box.

In the card-header-row example:
- padding: 1.5rem → space between the green border and the blue boxes inside
- gap: 2rem → space between company-logo and company-info (the two siblings)

Why gap is often cleaner than margin:
If you use margin on each child to create spacing between items, you often end up with unwanted margin on the first or last item (and have to remove it with :first-child or :last-child selectors). Gap only creates space BETWEEN items—never before the first or after the last.

Footnote on semantic tags:
When you do need a wrapper for a content section, using <section> instead of <div> is a minor win (screen readers, SEO, code clarity). But it doesn't reduce nesting—it's just a better label for a box you already needed.

RENDER INSTRUCTIONS:
Create a visual showing the "wrapper instinct" problem with a side-by-side comparison: (1) the original 5-level nesting diagram with dashed borders, and (2) the solution 2-level structure with solid borders showing the flex layout. Include a style breakdown table showing what CSS each element in the solution needs. Show three before/after code comparisons (HTML and CSS for each): card header, education spacing, and section width control. Include a box model diagram, then a separate section explaining where gap fits (it's not part of the box model—it's part of the layout system). Include a table showing padding vs gap vs margin. Include the four-question decision framework. End with a "Concepts to Explore Next" section linking to Box Model (Concept 5), Bootstrap Grid (Concepts 6-7), Flexbox (Concept 9), and Class Naming (Concept 4).


CONCEPT 2: CSS ORGANIZATION AND THE CASCADE

What it is:
CSS files should be organized logically so styles are easy to find and maintain. The cascade determines which styles apply when multiple rules target the same element - specificity (how specific the selector is) and source order (later rules override earlier ones) both matter. Well-organized CSS uses a table of contents comment, groups related styles together, and flows from general to specific.

How it appeared in original:
The original CSS had no organizational structure. Styles were added as needed, resulting in scattered rules. Related styles were separated (for example, .mainimage appeared, then unrelated styles, then media query adjustments for .mainimage much later). No comments explained sections. Specificity was inconsistent - sometimes using classes, sometimes IDs, sometimes element selectors combined with classes.

How it was applied in revL:
RevL CSS begins with a detailed comment block serving as documentation and table of contents. Styles are grouped into numbered sections: Color Theme Variables, Base Styles, Layout System, Hero Section, Content Sections, Card Components, etc. Each section has a comment header. Related responsive adjustments appear in a dedicated media queries section at the end rather than scattered throughout. Specificity is consistent - almost exclusively class-based selectors.

Key differences to note:
Original had no structure, revL has clear sections with headers like:
/* ============================================
   6. CARD COMPONENTS
   ============================================ */
This makes finding and modifying styles much faster.

RENDER INSTRUCTIONS:
Show the full table of contents comment from revL CSS. Create a visual diagram showing the recommended flow of a CSS file (reset, variables, base, layout, components, utilities, media queries). Include an example of how scattered original styles were consolidated in revL.

CONCEPT 3: CSS CUSTOM PROPERTIES AND THEMING

What it is:
CSS Custom Properties (also called CSS Variables) let you define reusable values that can be referenced throughout your stylesheet. Defined with double-dash prefix (--primary-color: blue) and used with var() function (color: var(--primary-color)). They make theming easy because changing one variable updates everywhere it is used. They also make your code more readable - var(--primary-color) is clearer than #004e89.

How it appeared in original:
The original used no CSS variables. Colors were hardcoded wherever needed: orange appeared directly in background properties, blue appeared directly in color properties, grey in borders. The same hex codes were repeated multiple times. Changing the color scheme would require finding and replacing every instance.

How it was applied in revL:
RevL does not actually implement CSS variables in the code but includes a detailed comment block documenting the color theme with instructions for find/replace. This is a halfway solution. The comments define: PRIMARY orange #ff6b35, SECONDARY blue #004e89, ACCENT light blue #1a659e, TEXT DARK navy #003459, TEXT LIGHT gray #666666, BORDER light gray #dee2e6, BACKGROUND LIGHT #f8f9fa, BACKGROUND WHITE #ffffff.

What should have been done (and what you should do):
Define variables in the :root selector at the top of CSS:
:root {
  --color-primary: #ff6b35;
  --color-secondary: #004e89;
  --color-text: #003459;
}
Then use throughout: background-color: var(--color-primary);

RENDER INSTRUCTIONS:
Show the color documentation comment from revL. Then show how it SHOULD be implemented with actual CSS variables. Create a small interactive demo or visual showing how changing one variable value updates multiple elements. Include the :root selector explanation.

CONCEPT 4: CLASS NAMING CONVENTIONS

What it is:
Class names should be consistent, descriptive, and follow a system. Common conventions include BEM (Block Element Modifier: block__element--modifier), component-based naming (component-part), and semantic naming (describes purpose not appearance). Good names are lowercase, use hyphens between words, and clearly indicate what they style.

How it appeared in original:
Original used inconsistent naming: some camelCase (titlecontainer), some underscores (section_heading, card_body), some descriptive (company_description), some vague (font_1, font_2), some mixed (nav_bar_text). IDs and classes were sometimes confused in purpose (id maincontainer used for styling). Names like font_1 tell you nothing about what text it styles.

How it was applied in revL:
RevL uses consistent hyphenated lowercase naming following a component-based pattern. Components are named for what they are: sidebar, main-content, content-section, experience-card, education-card, challenge-card, mindset-card. Sub-elements follow the pattern component-part: section-header, section-content, section-subheader, card-header-row, company-logo, company-info, company-name, job-title. States and variants use descriptive suffixes: date-highlight, mindset-icon-flip.

Naming system used in revL:
- Structural containers: sidebar, main-content, title-container, title-panel
- Section components: content-section, section-header, section-content, section-subheader
- Card variants: experience-card, education-card, challenge-card, mindset-card
- Card sub-elements: card-header-row, company-logo, company-info, company-name, job-title, company-description, job-description, employment-dates
- Specific elements: school-name, school-location, school-honors, school-dates
- Utility/state: date-highlight, mindset-icon-flip, article-link

RENDER INSTRUCTIONS:
Create a reference showing the naming transformation from original to revL for 8-10 examples. Include a quick-reference guide for the component-part naming pattern. Show how to derive class names systematically: identify the component, identify the part, combine with hyphen.

CONCEPT 5: THE CSS BOX MODEL

What it is:
Every HTML element is a box with four layers: content (the actual text/image), padding (space between content and border), border (the edge line), and margin (space between this box and other boxes). The box-sizing property controls whether width/height includes padding and border (border-box) or just content (content-box, the default). Using border-box makes sizing more intuitive because the width you set is the actual width including padding.

How it appeared in original:
Original had inconsistent box model usage. Some elements had box-sizing: content-box set explicitly (fullbox class in media query). Padding and margin were applied inconsistently - sometimes on the element, sometimes on children, sometimes with redundant properties. Many elements had margin-bottom: 0px followed by padding-bottom: 5px showing uncertainty about which property to use.

How it was applied in revL:
RevL sets box-sizing: border-box on all elements via the universal selector at the top of the CSS. This ensures consistent sizing behavior throughout. Padding is used for internal spacing (space inside the component), margin is used for external spacing (space between components). Margins are applied consistently using Bootstrap spacing utilities (mb-2, mt-4) or in a pattern where cards have margin-bottom for vertical rhythm.

Key pattern in revL:
Cards have padding for internal spacing: padding: 1.5rem
Cards have margin-bottom for vertical rhythm: margin-bottom: 2rem
Section-content has padding to create breathing room: padding: 2rem

RENDER INSTRUCTIONS:
Create a visual diagram of the box model showing content, padding, border, margin as nested rectangles. Show the difference between content-box and border-box with a concrete example (an element with width: 200px, padding: 20px). Pull an example from original where the box model was confusing and show the cleaner revL approach.

CONCEPT 6: BOOTSTRAP GRID SYSTEM (CONTAINERS, ROWS, COLUMNS)

What it is:
Bootstrap provides a 12-column grid system for creating layouts. It has three key components: containers (the outer wrapper that sets max-width and centers content), rows (flex containers that hold columns and apply negative margins to counteract column gutters), and columns (the actual content holders that use padding for gutters). The 12-column system means column widths are fractions of 12: col-6 is half width (6/12), col-4 is one-third (4/12), col-3 is one-quarter (3/12).

How it appeared in original:
Original used Bootstrap grid but inconsistently. Used container_one as a custom class instead of Bootstrap's container. Rows and columns were used but with hardcoded widths mixing with Bootstrap (col-md-3 for sidebar alongside position: fixed and width set in vh units). Columns did not always add up to 12. Empty columns (col-md-1) were used for spacing instead of Bootstrap offset classes. Some rows had width: 100% !important overriding Bootstrap.

How it was applied in revL:
RevL uses Bootstrap grid primarily for the content cards and two-column layouts within sections. The main page layout (sidebar plus content) is handled with custom CSS and fixed positioning rather than forcing Bootstrap to do something it is not designed for. Within sections, proper row and column usage appears:
- Education section: row with two col-md-6 columns (6+6=12)
- Challenges section: row with two col-md-6 columns
- Contact section: row with two col-md-6 columns
- Mindset section: row with col-lg-6 columns, using the lg breakpoint for wider content

Important Bootstrap grid rules:
1. Columns must be direct children of rows
2. Content goes inside columns, not directly in rows
3. Column classes should add up to 12 (or less, they will not fill the row)
4. Rows have negative margins that columns' padding counteracts - never put content directly in a row

RENDER INSTRUCTIONS:
Create a visual representation of the 12-column grid showing how col-6, col-4, col-3 divide space. Show original's problematic grid usage alongside revL's clean usage. Include a quick reference for common column combinations: 12 (full), 6+6 (halves), 4+4+4 (thirds), 3+3+3+3 (quarters), 8+4 (two-thirds plus one-third).

CONCEPT 7: BOOTSTRAP BREAKPOINTS AND RESPONSIVE CLASSES

What it is:
Bootstrap uses breakpoints - specific viewport widths where layout changes. The breakpoints are: xs (default, under 576px), sm (576px+), md (768px+), lg (992px+), xl (1200px+), xxl (1400px+). Column classes include breakpoint infixes to specify at which size they apply: col-12 is always 12 columns, col-md-6 is 6 columns at medium and up but 12 columns below medium. This enables responsive design without writing media queries.

How it appeared in original:
Original used col-md classes but inconsistently. The sidebar used col-md-3 but then was overridden with fixed positioning and custom widths. Many elements only had one breakpoint specified, causing awkward layouts at other sizes. The responsive behavior relied heavily on custom media queries at 991px rather than using Bootstrap's built-in responsive classes.

How it was applied in revL:
RevL uses Bootstrap breakpoints strategically. Column classes include responsive variants: col-md-6 for medium screens in education/challenge cards, col-lg-6 for larger breakpoint in mindset cards. Display utilities use breakpoints: d-none d-lg-flex hides sidebar below large screens, d-lg-none shows mobile nav only below large screens. The custom CSS media queries align with Bootstrap breakpoints (991px is just under lg at 992px).

Key responsive patterns in revL:
- Sidebar: visible only on lg and up via d-none d-lg-flex
- Mobile nav: visible only below lg via d-lg-none
- Content columns: col-md-6 means full width on mobile, half width on tablet and up
- Main content: margin-left only applied at lg+ breakpoint when sidebar appears

RENDER INSTRUCTIONS:
Create a breakpoint reference chart showing all Bootstrap breakpoints with pixel values. Show how a single element can have different column widths at different breakpoints using multiple classes. Demonstrate the d-none/d-lg-block pattern for showing/hiding elements. Include the sidebar/mobile-nav visibility pattern from revL as a practical example.

CONCEPT 8: BOOTSTRAP SPACING AND DISPLAY UTILITIES

What it is:
Bootstrap provides utility classes for common CSS properties so you can style elements without writing custom CSS. Spacing utilities follow the pattern: property-side-size. Property is m (margin) or p (padding). Side is t (top), b (bottom), s (start/left), e (end/right), x (left and right), y (top and bottom), or blank (all sides). Size is 0-5 (0, 0.25rem, 0.5rem, 1rem, 1.5rem, 3rem) or auto. Display utilities: d-none, d-block, d-flex, d-grid with optional breakpoint infixes.

How it appeared in original:
Original rarely used Bootstrap utilities, instead writing custom CSS for every spacing need. Resulted in repetitive CSS like margin-top: 10px, margin-bottom: 30px, padding-left: 30px, padding-right: 30px appearing on many different selectors with slightly different values. No consistency in spacing rhythm.

How it was applied in revL:
RevL uses Bootstrap spacing utilities in the HTML: g-4 (gutter size 4) on rows for consistent spacing between columns, mt-4 (margin-top size 4) for vertical spacing. Display utilities control visibility: d-none d-lg-flex on sidebar, d-lg-none on mobile nav, d-block on images, d-md-block on carousel captions (visible only on medium+). Flex utilities: flex-column on sidebar nav.

Common utilities in revL:
g-4: sets gutter (gap between columns) to 1.5rem
mt-4: margin-top 1.5rem
mb-2: margin-bottom 0.5rem
p-3: padding 1rem on all sides
me-2: margin-end (right) 0.5rem
d-flex: display flex
d-none: display none
d-lg-block: display block at lg breakpoint and up
flex-column: flex-direction column
align-items-center: vertical centering in flex container

RENDER INSTRUCTIONS:
Create a quick reference chart for spacing utilities showing the naming pattern with examples. Show original's repetitive margin/padding CSS versus using utilities. Include a display utility reference showing how to combine d-none with breakpoint classes for responsive show/hide.

CONCEPT 9: FLEXBOX LAYOUT

What it is:
Flexbox is a CSS layout mode for arranging items in a row or column with flexible sizing. The parent becomes a flex container (display: flex), children become flex items. Key container properties: flex-direction (row or column), justify-content (main axis alignment), align-items (cross axis alignment), gap (space between items), flex-wrap (allow wrapping). Key item properties: flex-grow, flex-shrink, flex-basis, or shorthand flex.

How it appeared in original:
Original used display: inline-block for the mindset icon rows, which caused alignment issues. The card header layout used Bootstrap row/column classes when flexbox would have been simpler. Some flexbox was used via Bootstrap classes (d-flex, flex-column) but not understood - the sidebar had flex classes but also conflicting custom positioning.

How it was applied in revL:
RevL uses flexbox extensively for component layouts. The sidebar uses flex-column via Bootstrap class. Card header rows use custom flexbox: display: flex, align-items: center, gap: 2rem, flex-wrap: wrap. This creates a row where logo and company info are vertically centered with consistent spacing, wrapping on small screens. Mindset icon rows use flexbox with justify-content: center for horizontal centering. Contact items use flex-direction: column to stack icon above label.

Key flexbox patterns in revL:
1. Card header: flex row with gap, items centered vertically, wraps on mobile
2. Sidebar nav: flex column, items stack vertically
3. Icon groups: flex row, small gap between icons
4. Contact items: flex column, centered both ways

RENDER INSTRUCTIONS:
Create visual diagrams showing flex-direction row vs column, justify-content options (flex-start, center, flex-end, space-between, space-around), align-items options. Show the card-header-row flexbox implementation from revL with annotated properties. Compare original's inline-block approach to revL's flexbox for the icon rows.

CONCEPT 10: FIXED POSITIONING AND THE SIDEBAR PATTERN

What it is:
Position: fixed removes an element from normal document flow and positions it relative to the viewport. It stays in place when the user scrolls. This is used for navigation that should always be visible. The sidebar pattern involves a fixed-position nav on one side with main content offset by the sidebar's width so they don't overlap.

How it appeared in original:
Original attempted this pattern but with issues. The sidebar had position: fixed and height: 100vh but was placed inside Bootstrap's column system, causing conflicts. The main content was in col-md-9 but the fixed sidebar didn't actually take up column space, so the layout math was wrong. Width was inconsistent between sidebar (col-md-3 plus custom width) and main offset.

How it was applied in revL:
RevL separates the sidebar from the Bootstrap grid entirely. The sidebar is a direct child of body, not inside any row/column structure. It uses position: fixed, left: 0, top: 0, width: 280px (fixed pixel width, not percentage), height: 100vh, z-index: 1000. The main content has margin-left: 280px at desktop breakpoints to offset exactly the sidebar width. Below lg breakpoint, sidebar is hidden and margin-left becomes 0.

Critical measurements in revL:
Sidebar width: 280px
Main content margin-left: 280px (at lg+)
Main content width: calc(100% - 280px) (at lg+)
These three values must be coordinated.

CRITICAL WARNING - FIXED POSITIONING AND BOOTSTRAP:
Never put position: fixed elements inside Bootstrap rows or columns. Fixed positioning removes the element from document flow entirely - it will ignore the column's width constraints and position itself relative to the viewport. This causes layout math to break because the column "thinks" it contains content but the fixed element isn't actually occupying that space. Always place fixed elements as direct children of body, outside any grid structure. Then use margin or padding on your main content area to create space for the fixed element.

RENDER INSTRUCTIONS:
Create a diagram showing the sidebar pattern with fixed positioning and main content offset. Show the problematic original approach (fixed inside grid columns) versus revL's clean separation. Include the CSS for both sidebar and main-content that makes them work together. Note the importance of matching widths. Include a prominent warning box about fixed positioning inside Bootstrap columns.

CONCEPT 11: THE HERO SECTION PATTERN

What it is:
A hero section is a large banner area, often full-viewport height, that creates visual impact at the top of a page. Common elements include a background image, overlay text, and sometimes a call-to-action. Challenges include making text readable over images, responsive sizing, and proper z-index layering.

How it appeared in original:
Original had a hero section using absolute positioning extensively. The title-container was position: relative (establishing positioning context), title-panel was position: absolute with height: 93vh, main-image was position: absolute with z-index: -1 (putting it behind), title-text was position: absolute with z-index: 6. The divider div with padding-top: 93vh pushed subsequent content down past the hero. Different values were used at different breakpoints (93vh vs 100vh).

How it was applied in revL:
RevL maintains the same general approach but with cleaner implementation. Title-panel is position: absolute, full width, 93vh height on mobile, 100vh on desktop. Main-image is position: absolute with z-index: 2. Title text (using ID selector #titletext) is position: absolute with z-index: 6, positioned using viewport units (top: 10vw, left: 2vw). The divider still uses padding-top to create space. At desktop, the image anchors to right: 0 instead of left positioning.

Key hero section elements:
1. Container with position: relative (positioning context)
2. Panel with position: absolute, full viewport height
3. Image with position: absolute, appropriate z-index
4. Text with position: absolute, higher z-index than image
5. Spacer element (divider) that pushes content below the hero

RENDER INSTRUCTIONS:
Create a layered diagram showing the z-index stacking of hero elements. Show the CSS for each layer. Explain the divider/spacer technique for pushing content below an absolutely-positioned hero. Include the responsive adjustments (different heights/positioning at different breakpoints).

CONCEPT 12: CARD COMPONENT PATTERN

What it is:
Cards are self-contained content containers with consistent styling. They typically have distinct areas: header (title, maybe image), body (main content), and footer (metadata, actions). Cards use visual separation (borders, shadows, background) to distinguish from surrounding content. A card pattern means reusable CSS that applies to multiple similar content blocks.

How it appeared in original:
Original had a .card class with basic styling: margin-top, padding-top, box-shadow, margin-bottom. But card structure was inconsistent - some cards had card_heading_container and card_heading inside, others didn't. Content classes were scattered: company_description, card_body, employment_dates as siblings with different spacing. The education cards and challenge cards used the same base .card class but with additional class .double that didn't appear to add styles.

How it was applied in revL:
RevL creates distinct card types with consistent internal structure. Base styling is duplicated across card types (experience-card, education-card, challenge-card, mindset-card) but each has appropriate internal classes. Experience cards have: card-header-row (flexbox header with logo and titles), company-description (italic intro), job-description (main content), employment-dates (gray footer bar). Education cards are simpler: school-name, school-location, school-honors, school-dates. Each card type has predictable structure.

Card anatomy in revL:
Experience card: header row (logo + info) | description | body | footer
Education card: name | location | honors | dates
Challenge card: title | description | result | outcome
Mindset card: icon row (icons + title) | description | example

RENDER INSTRUCTIONS:
Create a visual breakdown of each card type showing its internal structure. Compare original's inconsistent card structure to revL's systematic approach. Show the CSS for one complete card type (experience-card) with annotations explaining each property's purpose.

CONCEPT 13: TYPOGRAPHY, COLOR, AND VISUAL DESIGN BEST PRACTICES

What it is:
Typography hierarchy uses different font sizes, weights, and styles to show content importance and aid scanning. Headings (h1-h6) create hierarchy, but visual styling can differ from semantic level. Font stacks list multiple fonts in order of preference: the browser uses the first available. Color creates visual hierarchy and emotional tone - a limited, intentional palette looks professional while random colors look amateur. Good design uses consistent spacing, readable contrast, and intentional choices.

How it appeared in original:
Original defined two font classes: font_1 (font-family: georgia serif - note: missing comma, technically one font name) and font_2 (font-family: arial, sans-serif). These were applied inconsistently via HTML classes. No systematic hierarchy - the same class might be on a major heading and minor text. Title text size was set in media queries (font-size: x-large on mobile) but not systematically scaled. Colors were chosen ad-hoc: orange and blue mentioned in comments but applied inconsistently. Grey spelled differently in different places. No documented color system.

How it was applied in revL:
RevL sets base font-family on body (Georgia, serif - with comma). Headings get Arial via a grouped selector (h1, h2, h3, h4, h5, h6 { font-family: Arial, sans-serif }). Specific text elements get appropriate sizing: section-header h2 is 2rem, company-name is 1.25rem, job-title is 1rem, employment-dates is 0.9rem. Color indicates hierarchy: headings use the secondary blue (#004e89), body text is dark (#003459), secondary text is lighter (#666666).

Typography scale in revL:
Section headers: 2rem, white on orange background
Company/school names: 1.25rem / 1.1rem, blue (#004e89)
Job titles: 1rem, gray (#666666), normal weight
Body text: base size (1rem implied), dark navy (#003459)
Dates/metadata: 0.9rem, medium weight (500)
Highlights/accents: orange (#ff6b35), weight 500

Color palette in revL (documented at top of CSS):
PRIMARY (section headers, accents, highlights): #ff6b35 (vibrant orange)
SECONDARY (text headings, titles): #004e89 (deep blue)
ACCENT (hover states, links): #1a659e (lighter blue)
TEXT DARK (body text, nav): #003459 (navy)
TEXT LIGHT (descriptions, secondary): #666666 (medium gray)
BORDER (dividers, card edges): #dee2e6 (light gray)
BACKGROUND LIGHT (sidebar, nav): #f8f9fa (off-white)
BACKGROUND WHITE (content areas): #ffffff (white)

Color best practices:
1. Limit your palette to 2-3 main colors plus neutrals (grays, white, black)
2. Use one color for primary actions/emphasis (orange in revL)
3. Use one color for headings/titles (blue in revL)
4. Use neutral grays for body text and borders
5. Ensure sufficient contrast for readability (dark text on light background or vice versa)
6. Apply colors consistently - same element type gets same color everywhere
7. Document your colors at the top of CSS (or use CSS variables)

Typography best practices:
1. Use maximum 2 font families (one for headings, one for body)
2. Create a type scale with intentional size jumps (not random sizes)
3. Use font-weight to add hierarchy within a font family
4. Ensure body text is at least 16px (1rem) for readability
5. Maintain consistent line-height (1.5-1.6 for body text)
6. Use color to reinforce hierarchy (darker = more important, lighter = secondary)

Font stack syntax:
Correct: font-family: Georgia, Times, "Times New Roman", serif;
Incorrect: font-family: georgia serif; (missing comma makes this one invalid font name)
Always end with generic family: serif, sans-serif, monospace, cursive, fantasy

RENDER INSTRUCTIONS:
Show the typography hierarchy visually as a scale from largest to smallest with color coding. Create a color palette visualization showing all 8 colors from revL with their hex codes and usage. Compare original's font_1/font_2 approach to revL's systematic sizing. Include the correct font-stack syntax. Show examples of good contrast vs poor contrast.

CONCEPT 14: TRANSITIONS AND HOVER EFFECTS

What it is:
CSS transitions animate property changes over time rather than instantly. The transition property specifies: which property to animate (or 'all'), duration, timing function (ease, linear, etc.), and optional delay. Hover effects (via :hover pseudo-class) provide visual feedback for interactive elements. Combining them creates smooth, polished interactions.

How it appeared in original:
Original had no transitions defined. Any hover effects would be instant/jarring. No :hover rules were defined for navigation links, buttons, or interactive elements.

How it was applied in revL:
RevL adds transitions to interactive elements. Sidebar nav links: transition: all 0.3s ease with background-color change on hover. Contact icons: transition: transform 0.3s ease with transform: scale(1.1) on hover (10% size increase). Article links change color on hover. The timing (0.3s) and easing (ease) are consistent throughout for a cohesive feel.

Transition pattern in revL:
Base state: transition: all 0.3s ease (or transition: transform 0.3s ease for specific property)
Hover state: the property that changes (background-color, transform, color)
The transition is defined on the base state, not the hover state.

RENDER INSTRUCTIONS:
Show the CSS for a complete hover effect with transition (base state and hover state). Explain the transition property syntax. Show before/after (or rather, static/animated) concept. Pull the contact-icon example from revL as a practical demonstration.

CONCEPT 15: MEDIA QUERIES FOR RESPONSIVE DESIGN

What it is:
Media queries apply CSS rules conditionally based on device characteristics, most commonly viewport width. Syntax: @media (condition) { rules }. Common conditions: min-width (styles apply at this width and above), max-width (styles apply at this width and below). Mobile-first approach uses min-width (base styles for mobile, add complexity for larger screens). Desktop-first uses max-width (base styles for desktop, simplify for smaller screens).

How it appeared in original:
Original used max-width: 991px for mobile styles, meaning desktop-first approach. Media query styles were scattered throughout the file rather than consolidated. Many !important declarations were used to override base styles. Some rules in the media query seemed to fight against Bootstrap's grid rather than work with it.

How it was applied in revL:
RevL consolidates media queries at the end of the CSS file in a dedicated section. Uses both min-width: 991px (desktop and up) and max-width: 990px (tablet and below) as the main breakpoints, aligning with Bootstrap's lg breakpoint (992px). Desktop query adds sidebar offset and adjusts hero sizing. Mobile query removes sidebar, adjusts typography scaling, simplifies card layouts. A third query at max-width: 499px handles extra-small adjustments.

Media query organization in revL:
1. Base styles (apply to all sizes)
2. Desktop query (min-width: 991px): sidebar margin, hero adjustments
3. Tablet/mobile query (max-width: 990px): hide sidebar, show mobile nav, adjust cards
4. Extra small query (max-width: 499px): stack icons vertically

RENDER INSTRUCTIONS:
Show the structure of a well-organized media query section. Compare original's scattered queries with revL's consolidated approach. Create a visual showing how the same element is styled differently at different breakpoints. Include the common breakpoint values that align with Bootstrap.

CONCEPT 16: DEPRECATED PRACTICES AND COMMON MISTAKES TO AVOID

What it is:
HTML and CSS have evolved over decades. Some techniques that were once common are now deprecated (officially discouraged) or simply bad practice. Modern web development emphasizes separation of concerns (HTML for structure, CSS for presentation), maintainability, and clean code. Avoiding these mistakes makes code easier to read, debug, and maintain.

MISTAKE 1: Using br tags for spacing
The br (break) element creates a line break within text - like pressing Enter in a word processor. It should ONLY be used within text content where a line break is semantically meaningful (like poetry or addresses). It should NEVER be used to create vertical space between elements.

How it appeared in original:
The job descriptions used br br (double line breaks) to create paragraph spacing within the card_body content. This is using HTML to solve a CSS problem.

How to fix it:
Use CSS margin or padding for spacing. If you need space between paragraphs, either use actual p elements with margin-bottom, or add padding/margin to the container. If content truly needs to be in one element with breaks, consider whether it should actually be multiple elements.

Example fix:
Bad: First paragraph text br br Second paragraph text
Good: p First paragraph text /p p Second paragraph text /p
CSS: p { margin-bottom: 1rem; }

MISTAKE 2: Using the center tag
The center tag was deprecated in HTML4 (1999!) but still works in browsers. It should never be used in modern HTML. Centering is a presentational concern that belongs in CSS.

How it appeared in original:
The contact section used center tags to wrap images and captions: center a href img /a p caption /p /center

How to fix it:
Use CSS text-align: center on the parent for inline/inline-block content, or use flexbox with justify-content: center for block content, or use margin: 0 auto on a block element with a set width.

Example fix from revL:
The contact-item class uses: text-align: center; display: flex; flex-direction: column; align-items: center;
This centers both the inline content (text) and the flex children (icon) without any deprecated HTML.

MISTAKE 3: Inline styles
Inline styles are CSS written directly in HTML elements via the style attribute. They break separation of concerns, are hard to maintain (can't change all instances at once), override external CSS (high specificity), and make HTML cluttered and hard to read.

How it appeared in original:
The sidebar nav had inline styles: style="height: 100vh; position:fixed;"
The navbar container had: style="position:fixed; z-index:5;"
Various elements had style attributes mixed with classes.

How to fix it:
Move ALL styling to your external CSS file. If an element needs specific styling, give it a class and style that class. The only acceptable inline style is when JavaScript dynamically sets a value that changes (like animation positions), and even then there are often better alternatives.

MISTAKE 4: Unclosed or misaligned div tags
Every opening tag needs a closing tag. When divs are deeply nested, it's easy to lose track and either forget to close a div or close them in the wrong order. This causes unpredictable layout issues and invalid HTML.

How it appeared in original:
The original had complex nesting that was hard to follow. The mindset section's gridline_container contained rows and columns with multiple levels, making it easy to lose track.

How to fix it:
1. Use proper indentation - child elements should be indented one level from parents
2. Add HTML comments marking section endings: /div closing end of sidebar
3. Use your code editor's bracket matching feature
4. Validate your HTML with the W3C validator
5. Reduce nesting depth - if you're more than 4-5 levels deep, consider restructuring

MISTAKE 5: position: fixed inside Bootstrap columns
Bootstrap's grid uses percentage widths, padding, and margin calculations that assume elements are in normal document flow. Fixed positioning removes an element from the flow and positions it relative to the viewport. Putting fixed elements inside Bootstrap columns causes conflicts - the column structure doesn't actually constrain the fixed element.

How it appeared in original:
The sidebar was inside a col-md-3 but also had position: fixed. The column had no effect on the fixed element's size or position, but the main content was in col-md-9, creating misalignment because the fixed sidebar wasn't actually taking up column space.

How to fix it:
Keep fixed-position elements OUTSIDE the Bootstrap grid entirely. In revL, the sidebar is a direct child of body, not inside any row/column structure. The main content then uses margin-left to offset itself, matching the sidebar's pixel width (not a column fraction).

MISTAKE 6: Overusing !important
The !important declaration forces a style to override all other rules regardless of specificity. It's a sledgehammer that breaks the natural cascade. Overusing it leads to specificity wars where you need !important to override other !important rules.

How it appeared in original:
Multiple !important declarations in media queries: width: 100vw !important; width: 100% !important; padding-top: 100vh !important;
These were needed because the base styles and Bootstrap were fighting.

How to fix it:
1. Increase specificity naturally (add a class, be more specific with selectors)
2. Check source order - later rules override earlier ones at same specificity
3. Avoid fighting Bootstrap - work with its patterns or override cleanly at the right specificity level
4. Reserve !important for utility classes that MUST always apply (like .hidden { display: none !important; })

RENDER INSTRUCTIONS:
Create a do/don't comparison for each mistake showing bad code from original and good code from revL or best practice. Include visual indicators (red X for bad, green check for good). Show the center tag replacement with flexbox visually. Include the W3C validator URL as a resource.

END STUDY GUIDE

BEGIN BLUEPRINT

BLUEPRINT SECTION 1: HTML BOILERPLATE AND HEAD SETUP

Purpose: Every HTML document starts with the same foundational structure. This section establishes the document, loads external resources, and sets metadata.

Structure:
1. DOCTYPE declaration (tells browser this is HTML5)
2. html element with lang attribute (accessibility and SEO)
3. head element containing:
   - charset meta (character encoding, always utf-8)
   - viewport meta (enables responsive design on mobile)
   - title element (appears in browser tab)
   - description meta (SEO)
   - author meta (optional)
   - Bootstrap CSS link (CDN)
   - Bootstrap JavaScript (CDN, include Bundle version for all components)
   - Bootstrap Icons CSS (CDN, for icon fonts)
   - Custom CSS link (your stylesheet, loaded AFTER Bootstrap so it can override)
4. body element (all visible content goes here)

Key points:
- Bootstrap CSS must load before your custom CSS
- Bootstrap JS should use the bundle version which includes Popper.js
- Viewport meta with initial-scale=1 is required for responsive design to work

References concepts: 2 (CSS Organization - load order matters)

RENDER INSTRUCTIONS:
Show a complete HTML boilerplate with all elements annotated. Explain each meta tag's purpose. Show correct Bootstrap CDN links (use version 5.3.3 as in source files). Emphasize the CSS load order importance.

BLUEPRINT SECTION 2: NAVIGATION (DESKTOP SIDEBAR AND MOBILE NAVBAR)

Purpose: Navigation helps users move through the page. This pattern uses two separate nav elements - a fixed sidebar visible only on large screens, and a collapsible navbar visible only on smaller screens. Bootstrap's display utilities control which is visible.

Structure overview:
- nav.sidebar (desktop) - direct child of body, not inside any container
- nav.navbar (mobile) - direct child of body, fixed to top
- main.main-content - the rest of the page content

Desktop sidebar structure:
nav element with classes: sidebar d-none d-lg-flex flex-column bg-light
Contains:
- Logo link with img
- ul.nav.nav-pills.flex-column containing li elements with a.nav-link children
- Each nav-link has: Bootstrap icon (i.bi.bi-iconname), text
- href attributes point to section IDs (#about, #experience, etc.)

Mobile navbar structure:
nav element with classes: navbar navbar-expand-lg navbar-light bg-light d-lg-none fixed-top
Contains:
- div.container-fluid
- a.navbar-brand (site title)
- button.navbar-toggler (hamburger menu button) with data-bs-toggle="collapse" and data-bs-target="#mobileNav"
- div.collapse.navbar-collapse#mobileNav containing ul.navbar-nav with li.nav-item and a.nav-link children
- Nav links can include data-bs-toggle="collapse" data-bs-target=".navbar-collapse.show" to auto-close menu on click

CSS for sidebar:
position: fixed; left: 0; top: 0; width: 280px; height: 100vh; z-index: 1000; overflow-y: auto;

CSS for main-content at desktop breakpoint:
margin-left: 280px; width: calc(100% - 280px);

References concepts: 7 (Breakpoints), 8 (Display utilities), 10 (Fixed positioning)

RENDER INSTRUCTIONS:
Show complete HTML for both navigation elements with class annotations. Show the CSS that makes them work (sidebar fixed positioning, main-content offset). Explain the d-none d-lg-flex and d-lg-none pattern for toggling visibility. Show how nav links connect to section IDs.

BLUEPRINT SECTION 3: HERO/TITLE SECTION

Purpose: The hero creates visual impact and establishes identity. This implementation uses absolute positioning to layer a large image with overlaid text.

Structure:
div.title-container (relatively positioned wrapper)
  div.title-panel (absolutely positioned panel, viewport height)
    img.main-image (absolutely positioned, behind text)
    div#titletext (absolutely positioned text container)
      h1.title-text (the actual headline)
div.divider (spacer element that pushes content below)

CSS layering:
- title-container: position: relative (creates positioning context)
- title-panel: position: absolute; height: 93vh (mobile) or 100vh (desktop); width: 100%; overflow: hidden
- main-image: position: absolute; z-index: 2; right: 0 (desktop) or left: 20vw (mobile)
- #titletext: position: absolute; z-index: 6; top: 10vw; left: 2vw
- divider: padding-top: 93vh (matches panel height) to push subsequent content down

Why this works:
Absolutely positioned elements are removed from document flow, so they don't push other content. The divider's padding creates the necessary space. Z-index controls stacking order - higher values appear on top.

References concepts: 11 (Hero pattern), 5 (Box model - padding for spacer)

RENDER INSTRUCTIONS:
Show the complete HTML structure with annotations. Show CSS for each element with z-index layering visualized. Explain the spacer/divider technique. Show mobile vs desktop differences.

BLUEPRINT SECTION 4: CONTENT SECTIONS (REPEATABLE PATTERN)

Purpose: Content sections are the repeatable building blocks of the page. Each section follows the same structure: colored header bar with title, content area below with appropriate padding.

Structure for each section:
section#sectionid.content-section
  div.section-header
    h2 (section title)
  div.section-content
    (content specific to this section - cards, text, etc.)

Semantic element choice:
- Use section element with meaningful ID
- ID enables navigation links (#about, #experience)
- Class enables consistent styling

CSS for section-header:
background-color: (primary color); padding: 1rem 2rem; width: 100%;
h2 inside: color: white; margin: 0; font-size: 2rem;

CSS for section-content:
padding: 2rem; max-width: 1200px; margin: 0 auto; background-color: white;
(max-width and margin auto centers content and limits line length for readability)

Optional subheader pattern:
h3.section-subheader or h4.section-subheader
CSS: border-left: 4px solid (primary color); padding-left: 1rem; margin-bottom: 1.5rem; color: (secondary color);

References concepts: 1 (Semantic HTML), 4 (Class naming), 5 (Box model)

RENDER INSTRUCTIONS:
Show the HTML pattern for a generic content section. Show the CSS with property explanations. Demonstrate how multiple sections stack vertically with consistent appearance.

BLUEPRINT SECTION 5: CARD COMPONENTS

Purpose: Cards contain discrete pieces of content with consistent styling. Different card types serve different content needs but share visual DNA.

Common card CSS:
background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-radius: 4px; overflow: hidden;

EXPERIENCE CARD (complex, multi-part):
Structure:
div.experience-card
  div.card-header-row (flexbox row)
    div.company-logo (contains img)
    div.company-info
      h3.company-name
      h4.job-title
  p.company-description (italic introduction)
  p.job-description (main content)
  p.employment-dates (footer bar)

CSS for card-header-row:
display: flex; align-items: center; gap: 2rem; padding: 1.5rem; border-bottom: 1px solid (border color); flex-wrap: wrap;

CSS for employment-dates footer:
background-color: (light gray); padding: 0.75rem 1.5rem; margin: 0; border-top: 1px solid (border color);

EDUCATION CARD (simple, stacked):
Structure:
div.education-card
  h4.school-name
  p.school-location
  p.school-honors
  p.school-dates (with span.date-highlight for emphasis)

CHALLENGE CARD (narrative):
Structure:
div.challenge-card
  h4.challenge-title
  p.challenge-description
  p.challenge-result
  p.challenge-outcome (styled as outcome/conclusion)

MINDSET/FEATURE CARD (icons + content):
Structure:
div.mindset-card
  div.mindset-icon-row (flexbox with icons and title)
    div.icon-group (groups related icons)
      img.mindset-icon (multiple)
    h5.mindset-title
    div.icon-group
      img.mindset-icon
  p.mindset-description
  p.mindset-example

Cards within Bootstrap grid:
Place cards inside col- classes within a row. Example for two equal-width cards:
div.row.g-4
  div.col-md-6
    div.education-card (content)
  div.col-md-6
    div.education-card (content)

References concepts: 6 (Grid), 9 (Flexbox), 12 (Card pattern), 4 (Class naming)

RENDER INSTRUCTIONS:
Show HTML structure for each card type. Show the CSS that creates visual separation (shadow, border-radius). Demonstrate cards within Bootstrap grid. Show flexbox properties for card-header-row.

BLUEPRINT SECTION 6: CAROUSEL/GALLERY COMPONENT

Purpose: Display multiple images/content items in a rotating gallery. Uses Bootstrap's carousel component.

Structure:
div#carouselId.carousel.slide (data-bs-ride="carousel" for auto-play)
  div.carousel-indicators (dots showing position)
    button (for each slide, data-bs-slide-to="0", "1", etc.)
  div.carousel-inner
    div.carousel-item.active (first item must have .active)
      img.d-block.w-100
      div.carousel-caption.d-none.d-md-block (hidden on small screens)
        h5 (caption title)
        p (caption text/link)
    div.carousel-item (subsequent items, no .active)
      (same structure)
  button.carousel-control-prev (data-bs-target="#carouselId" data-bs-slide="prev")
    span.carousel-control-prev-icon
    span.visually-hidden (Previous)
  button.carousel-control-next (data-bs-target="#carouselId" data-bs-slide="next")
    span.carousel-control-next-icon
    span.visually-hidden (Next)

Key Bootstrap carousel requirements:
- Unique ID on carousel container
- data-bs-target on controls and indicators must match ID (with #)
- First carousel-item must have .active class
- Images typically use d-block w-100 for responsive full-width

Custom CSS for consistent height:
.carousel-item { height: 500px; }
.carousel-item img { width: 100%; height: 100%; object-fit: cover; object-position: center; }

References concepts: 8 (Display utilities for caption), 7 (Breakpoints - d-md-block)

RENDER INSTRUCTIONS:
Show complete carousel HTML with all required data attributes. Explain the ID/target relationship. Show CSS for consistent image sizing with object-fit. Note the active class requirement.

BLUEPRINT SECTION 7: CONTACT AND CALL-TO-ACTION SECTION

Purpose: Provide clear ways to connect. Simple layout with prominent clickable elements.

Structure:
section#contact.content-section
  div.section-header
    h2 (Contact)
  div.section-content
    div.row.g-4
      div.col-md-6
        div.contact-item
          a (href="mailto:email@example.com")
            img.contact-icon (email icon)
          p.contact-label (Email Address)
      div.col-md-6
        div.contact-item
          a (href="url" target="_blank")
            img.contact-icon (icon image)
          p.contact-label (label text)

CSS for contact-item (centering icon and label):
text-align: center; padding: 2rem; display: flex; flex-direction: column; justify-content: center; align-items: center;

CSS for contact-icon (size and interaction):
max-width: 100px; height: auto; margin-bottom: 1rem; transition: transform 0.3s ease;

CSS for contact-icon:hover:
transform: scale(1.1);

Resume/download section follows same pattern with download attribute on link:
a (href="filename.pdf" download)

References concepts: 9 (Flexbox centering), 14 (Transitions/hover), 6 (Grid for columns)

RENDER INSTRUCTIONS:
Show HTML for contact section with two-column layout. Show CSS for centering and hover effect. Demonstrate mailto and download link syntax.

BLUEPRINT SECTION 8: PUTTING IT ALL TOGETHER (FULL PAGE STRUCTURE)

Purpose: Understanding how all pieces combine into a complete page.

Complete page outline:
1. DOCTYPE and html open
2. head (meta, title, CSS links, JS)
3. body opens
4. nav.sidebar (desktop, fixed) - outside any container
5. nav.navbar (mobile, fixed) - outside any container
6. main.main-content opens
7. Hero section (title-container, title-panel, image, text, divider)
8. Content sections (repeating pattern):
   - section#about.content-section
   - section#experience.content-section
   - section#education.content-section
   - (additional sections as needed)
9. Carousel section
10. Contact section
11. Resume/CTA section
12. main closes
13. body closes
14. html closes

CSS file organization:
1. Comment header with documentation
2. CSS Variables (:root)
3. Base/reset styles (*, body, typography)
4. Layout (sidebar, main-content positioning)
5. Hero section styles
6. Content section styles (header, content wrapper)
7. Card component styles (each card type)
8. Carousel overrides
9. Contact/utility styles
10. Media queries (consolidated at end)

Responsive strategy:
- Base styles work for mobile
- lg breakpoint (991px+) adds sidebar, adjusts hero
- md breakpoint affects grid columns (col-md-6)
- Additional small-screen adjustments as needed

References concepts: All concepts apply in full implementation

RENDER INSTRUCTIONS:
Create a visual site map or wireframe showing all sections in order. Show a condensed version of both complete HTML structure and CSS organization. Provide a checklist for building a similar site from scratch.

END BLUEPRINT

FINAL NOTES FOR FUTURE CLAUDE USE:
When rendering any section, always pull specific code examples from the source files (index.html, style.css, index_clauderevL.html, style_clauderevL.css) to show before/after comparisons where relevant. Use visual diagrams, comparison tables, and annotated code blocks. The user learns best from seeing concrete examples alongside explanations. Each render should be self-contained and usable as a reference. Format renders as visually appealing HTML or React artifacts with good typography and spacing.
